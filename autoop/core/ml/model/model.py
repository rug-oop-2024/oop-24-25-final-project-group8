
from abc import ABC, abstractmethod
from copy import deepcopy
import numpy as np
from pydantic import PrivateAttr

from autoop.core.ml.artifact import Artifact

class Model(Artifact, ABC):
    """
    Represents a generic Machine Learning model.
    This class serves as a base class for both classification and regression tasks.
    ("COPIED AND ADAPTED FROM ASSIGNMENT 1") 
    """

    def __init__(self, type: str = "model", hyperparameters: dict = None):
        super().__init__(type=type)
        self._hyperparameters = deepcopy(hyperparameters) if hyperparameters else {}
        self._parameters = {}

    @abstractmethod
    def fit(self, observations: np.ndarray, ground_truth: np.ndarray) -> None:
        """
         Fit the model to the observations and ground truth data.

        This method takes in observations (input data) and ground truth
        (actual values) and adjusts the model's parameters accordingly.

        :param observations: Input data or features the model will learn from.
        :type observations: np.ndarray
        :param ground_truth: Actual values of the target variable
            used to adjust the model's parameters during training.
        :type ground_truth: np.ndarray
        """
        pass

    @abstractmethod
    def predict(self, observations: np.ndarray) -> np.ndarray:
        """
        Make predictions using the model for the given observations.

        This method takes an array of observations as input and returns an
        array of predictions generated by the model.

        :param observations: Data or observations for which predictions
                             are to be made.
                             Should be a NumPy array with the
                             appropriate shape.
        :type observations: np.ndarray
        :return: Predictions as a NumPy array.
        :rtype: np.ndarray
        """
        pass

    def _validate_input(
        self, observations: np.ndarray, ground_truth: np.ndarray
    ) -> None:
        """
        Checks that the input data is of the correct shape and dimensionality.

        :param observations: Input data or features the model will learn from or predict on.
        :type observations: np.ndarray
        :param ground_truth: Actual values of the target variable used during training.
        :type ground_truth: np.ndarray
        :raises ValueError: If the number of observations and ground_truth do not match.
        :raises ValueError: If observations is not a 2D array.
        :raises ValueError: If observations has no samples or no features.
        """
        if observations.shape[0] != ground_truth.shape[0]:
            raise ValueError(
                f"Mismatch in number of samples: Observations have {observations.shape[0]} samples, "
                f"but ground truth has {ground_truth.shape[0]} samples."
            )

        if observations.ndim != 2:
            raise ValueError(
                f"Observations should be a 2-D array, but got {observations.ndim}D array instead."
            )

        num_samples, num_features = observations.shape
        if num_samples < 1 or num_features < 1:
            raise ValueError("The input data must have at least one sample and one feature.")

        if num_features > num_samples:
            print(
                "Warning: Detected more features than samples! "
                "Are you sure that the samples are in observations[0] and features in observations[1]?"
            )

        self._parameters["num_features"] = num_features

    def _validate_num_features(self, observations: np.ndarray) -> None:
        """
        Validate that the number of features in the input observations matches
        the number of features used during model fitting.

        :param observations: The input data for which predictions will be made.
        :raises ValueError: If the number of features during fit and predict differ.
        """
        num_features = self._parameters.get("num_features", None)
        if num_features is not None and observations.shape[1] != num_features:
            raise ValueError(
                f"Number of dimensions from fitting the data ({num_features}) don't match input "
                f"observations in predicting the data ({observations.shape[1]})."
            )

    @abstractmethod
    def _validate_fit(self) -> None:
        """
        Function used to validate if the fitting process has been executed as expected.
        """
        pass

    @property
    def parameters(self) -> dict:
        """
        Return the model parameters.

        :return: A dictionary containing the model's parameters.
        """
        return deepcopy(self._parameters)

    @property
    def hyperparameters(self) -> dict:
        """
        Return the model hyperparameters.

        :return: A dictionary containing the model's hyperparameters.
        """
        return deepcopy(self._hyperparameters)

    def set_hyperparameters(self, hyperparameters: dict) -> None:
        """
        Set the model hyperparameters.

        :param hyperparameters: A dictionary containing the hyperparameters.
        """
        self._hyperparameters = deepcopy(hyperparameters)

    def set_parameters(self, params: dict) -> None:
        """
        Set the model parameters.

        :param params: Dictionary of model parameters (weights, biases, etc.).
        """
        self._parameters = deepcopy(params)

    def save(self, file_path: str) -> None:
        """
        Save the model's parameters and hyperparameters to a file using the Artifact class.
        """
        model_data = {
            "parameters": self._parameters,
            "hyperparameters": self._hyperparameters,
        }
        # Use Artifact's save functionality to store model data
        super().save(data=model_data, artifact_type="model", filename=file_path)

    def load(self, file_path: str) -> None:
        """
        Load the model's parameters and hyperparameters from a file using the Artifact class.
        """
        # Call the Artifact class's load() to load data into self.data
        super().load(file_path)

        # Now, extract parameters and hyperparameters from self.data
        self._parameters = self.data.get("parameters", {})
        self._hyperparameters = self.data.get("hyperparameters", {})